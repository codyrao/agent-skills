# 缓存一致性规范

## 缓存使用原则

### 最终一致性场景
- 可以容忍最终一致性的场景必须使用缓存
- 读多写少的场景优先使用缓存
- 热点数据必须使用缓存
- 计算成本高的数据应使用缓存

### 强一致性场景
- 需要强一致性的场景不要使用缓存
- 涉及资金、库存等核心业务数据不使用缓存
- 实时性要求高的数据不使用缓存
- 频繁更新的数据不使用缓存

### 缓存适用场景
- 读多写少的数据
- 计算成本高的数据
- 热点数据
- 不经常变化的数据
- 可以容忍短暂不一致的数据

### 缓存不适用场景
- 写多读少的数据
- 频繁变化的数据
- 需要强一致性的数据
- 实时性要求高的数据
- 数据量小的数据

## 缓存策略

### Cache Aside（旁路缓存）
- 读操作：先读缓存，缓存未命中则读数据库，然后写入缓存
- 写操作：先更新数据库，然后删除缓存
- 适用于读多写少的场景
- 是最常用的缓存策略

### Read Through（读穿透）
- 读操作：先读缓存，缓存未命中则由缓存层读取数据库并写入缓存
- 写操作：先更新数据库，然后更新缓存
- 适用于读多写少的场景
- 缓存层负责数据的加载

### Write Through（写穿透）
- 读操作：先读缓存，缓存未命中则由缓存层读取数据库并写入缓存
- 写操作：先更新缓存，然后由缓存层更新数据库
- 适用于读写均衡的场景
- 缓存层负责数据的写入

### Write Behind（写回）
- 读操作：先读缓存，缓存未命中则由缓存层读取数据库并写入缓存
- 写操作：先更新缓存，然后异步更新数据库
- 适用于写多读少的场景
- 存在数据丢失风险

## 缓存更新策略

### 先更新数据库，后删除缓存
- 适用于读多写少的场景
- 存在短暂的不一致窗口
- 实现简单，性能较好

### 先删除缓存，后更新数据库
- 适用于写多读少的场景
- 存在短暂的不一致窗口
- 需要配合延迟双删

### 延迟双删
- 先删除缓存
- 更新数据库
- 延迟一段时间后再次删除缓存
- 适用于高并发场景
- 可以减少不一致的时间窗口

### 分布式锁
- 使用分布式锁保证缓存更新的顺序
- 适用于高并发场景
- 性能较差

## 缓存穿透

### 问题定义
- 大量请求查询不存在的数据
- 缓存未命中，请求直接打到数据库
- 可能导致数据库压力过大

### 解决方案
- 缓存空值：将不存在的数据缓存为空值，设置较短的过期时间
- 布隆过滤器：使用布隆过滤器判断数据是否存在
- 请求限流：对不存在的数据请求进行限流
- 缓存预热：提前将热点数据加载到缓存

### 空值缓存
- 缓存空值的过期时间设置较短（如 30 秒）
- 使用特殊标记标识空值缓存
- 定期清理空值缓存

### 布隆过滤器
- 使用布隆过滤器判断数据是否存在
- 布隆过滤器存在一定的误判率
- 需要定期更新布隆过滤器

## 缓存击穿

### 问题定义
- 热点数据过期
- 大量请求同时查询该数据
- 缓存未命中，请求同时打到数据库
- 可能导致数据库压力过大

### 解决方案
- 互斥锁：使用分布式锁保证只有一个请求查询数据库
- 永不过期：热点数据设置永不过期，后台异步更新
- 热点数据预热：提前将热点数据加载到缓存

### 互斥锁
- 使用分布式锁（如 Redis SETNX）
- 只有一个请求查询数据库
- 其他请求等待或返回默认值
- 查询完成后释放锁

### 永不过期
- 热点数据设置永不过期
- 后台异步更新缓存
- 更新时使用互斥锁
- 需要监控缓存命中率

## 缓存雪崩

### 问题定义
- 大量缓存同时过期
- 大量请求同时打到数据库
- 可能导致数据库压力过大甚至宕机

### 解决方案
- 过期时间随机化：为缓存设置随机的过期时间
- 缓存预热：提前将热点数据加载到缓存
- 限流降级：对数据库请求进行限流降级
- 高可用缓存：使用缓存集群保证高可用

### 过期时间随机化
- 在基础过期时间上增加随机值
- 随机值范围为基础过期时间的 10%-20%
- 避免大量缓存同时过期

### 缓存预热
- 系统启动时加载热点数据
- 定期刷新热点数据
- 使用后台任务预热缓存

### 限流降级
- 对数据库请求进行限流
- 超过阈值时返回默认值
- 实现服务降级

## 缓存一致性保证

### 最终一致性
- 缓存和数据库之间存在短暂的不一致
- 不一致的时间窗口应尽可能短
- 通过合理的更新策略减少不一致时间

### 强一致性
- 使用分布式锁保证强一致性
- 使用事务保证强一致性
- 性能较差，仅适用于核心业务

### 一致性级别
- 读一致性：读取的数据可能不是最新的
- 写一致性：写入的数据可能不会立即反映到缓存
- 最终一致性：经过一段时间后，缓存和数据库最终一致

## 缓存过期策略

### 过期时间设置
- 热点数据：设置较长的过期时间（如 1 小时）
- 普通数据：设置中等的过期时间（如 10 分钟）
- 冷数据：设置较短的过期时间（如 1 分钟）
- 空值缓存：设置较短的过期时间（如 30 秒）

### 过期时间随机化
- 在基础过期时间上增加随机值
- 随机值范围为基础过期时间的 10%-20%
- 避免大量缓存同时过期

### 过期时间更新
- 读取缓存时更新过期时间（被动更新）
- 定期刷新热点数据（主动更新）
- 使用后台任务更新过期时间

## 缓存监控

### 缓存命中率
- 监控缓存命中率
- 命中率低于 80% 时告警
- 分析未命中的原因

### 缓存响应时间
- 监控缓存响应时间
- 响应时间超过 10ms 时告警
- 分析响应时间慢的原因

### 缓存容量
- 监控缓存容量使用率
- 容量使用率超过 80% 时告警
- 及时清理过期数据

### 缓存错误率
- 监控缓存错误率
- 错误率超过 1% 时告警
- 分析错误原因

## 缓存最佳实践

### 缓存设计
- 缓存 key 设计合理，具有描述性
- 缓存 value 大小适中（不超过 1MB）
- 缓存过期时间设置合理
- 缓存数据结构选择合适

### 缓存更新
- 使用合适的缓存更新策略
- 更新时使用分布式锁
- 更新失败时记录日志

### 缓存降级
- 缓存不可用时降级到数据库
- 降级策略清晰
- 提供降级通知

### 缓存预热
- 系统启动时加载热点数据
- 定期刷新热点数据
- 使用后台任务预热缓存

## 禁止事项

- 禁止在需要强一致性的场景使用缓存
- 禁止在涉及资金、库存等核心业务数据使用缓存
- 禁止在频繁更新的数据使用缓存
- 禁止使用 `KEYS *` 命令遍历缓存
- 禁止使用大 key（超过 1MB）
- 禁止使用大 value（超过 10MB）
- 禁止使用阻塞命令（BLPOP、BRPOP）
- 禁止使用 Lua 脚本执行耗时操作
- 禁止使用 O(N) 复杂度的命令处理大数据集
- 禁止使用 SCAN 遍历整个数据库
- 禁止在生产环境执行 `FLUSHALL` 和 `FLUSHDB`
